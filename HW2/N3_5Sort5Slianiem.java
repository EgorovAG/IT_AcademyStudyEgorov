
// Сортировка слиянием
/*
Массив сразу разбивается на отдельные подмассивы состоящие по одному элементу.
Далее 2 массива с количеством по 1 элементу слияются в 1 и получается общий массив
с 2-мя элементами и они сразу в момент слияния сортируются. Далее 2 массива с 2 элементами каждый
слияются в общий массив с 4 -мя элементами и тоже упорядочненными. И т.д.
В консоль выводится процесс слияния
*/

//    1. Найдите среднюю точку, чтобы разделить массив на две половины:
//    2. Вызовите mergeSort для первой половины:
//    Вызовите mergeSort
//    3. Вызовите mergeSort для второй половины:
//    Вызовите mergeSort
//    4. Объедините две половины, отсортированные на шаге 2 и 3:
//    Вызов слияния

import java.util.Arrays;

public class N3_5Sort5Slianiem {
        public static void main(String args[]) {
            int array[] = {12, 11, 13, 5, 6, 7};
            for (int element:array) {
                System.out.print(element+" ");
            }

            sort(array, 0, array.length-1);
            System.out.println();
            System.out.println(Arrays.toString(array));
        }

// слияние двух подмассивов arr[].
// первый подмассив arr[st..mid]
// второй подмассив arr[mid+1..end]

        static void merge(int arr[], int st, int mid, int end)
        {
            // находим размеры двух подмассивов для слияния
            int n1 = mid - st + 1;
            int n2 = end - mid;

            /* Создаем временные массивы массивы */
            int L[] = new int[n1];
            int R[] = new int[n2];

            /*Копируем данные во временные массивы*/
            for(int i=0; i<n1; ++i)
                L[i] = arr[st + i];
            for(int j=0; j<n2; ++j)
                R[j] = arr[mid + 1+ j];

            /* Слияние временных массивов */

            // Инициализируем индексы первого и второго подмассивов

            int i = 0, j = 0;

            // Initial index of merged subarray array
            // Инициализируем индекс объединенного массива подмассива
            int k = st;
            while(i < n1 && j < n2)
            {
                if(L[i] <= R[j])
                {
                    arr[k] = L[i];
                    i++;
                }
                else
                {
                    arr[k] = R[j];
                    j++;
                }
                k++;
            }

            /* Скопировать оставшиеся элементы L[] если есть */
            while(i < n1)
            {
                arr[k] = L[i];
                i++;
                k++;
            }

            /* Скопировать оставшиеся элементы R[] если есть */
            while(j < n2)
            {
                arr[k] = R[j];
                j++;
                k++;
            }
        }

        // Main функкция которая сортиует arr[l..r] используя
        // merge()

        static void sort(int arr[], int l, int r)
        {
            if(l < r)
            {
                // Поиск средней точки
                int m = (l+r)/2;

                // Сортировка первой и второй половинки
                sort(arr, l, m);
                sort(arr , m+1, r);

                // Слияние сортрованных половинок
                merge(arr, l, m, r);
            }
        }
    }